---
title: "Changes Deliverable 3"
author: "Stan Broers"
date: "2025-02-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
In today’s entertainment landscape, whether a TV series will be renewed for a second season is relevant and intriguing. Understanding the factors influencing renewal decisions can provide valuable insights for content creators, streaming platforms, and researchers studying audience engagement.

# Research objectives
This research seeks to investigate whether popular genres have a higher likelihood of renewal, if the language of the title plays a role in renewal decisions, and the significance of average ratings. It might seem intuitive that higher ratings lead to renewal ((What’s Behind a Show Renewal, n.d.).

# Methodology
To explore these factors, we will conduct a logistic regression analysis. The renewal status will be the dependent variable, while genre, language of the title, and average rating will serve as the independent variable. According to Lee and Wang (2003), logistic regression is a useful method for analyzing binary variables because it models and predicts the probability of a specific outcome. This method is useful as it can handle both continuous and categorial predictors, making it versatile for various types of data. 

#Expected contributions
The findings of this study can contribute to both academic and industry discussions. By identifying patterns in renewal decisions, this research can aid content creators and streaming services make informed choices about future productions. Additionally, the automated and reproducible workflow ensures that this research can be a valuable resource for other students and the broader scientific community.
Deployment
For deployment, the results will be communicated through a PDF report, ensuring accessibility and clarity for potential users. The structured format will effectively present conclusions, making it easy to interpret key findings.

#sources

Lee, E. T., & Wang, J. W. (2003). Statistical methods for survival data analysis. In Wiley series in probability and statistics. https://doi.org/10.1002/0471458546
What’s behind a show renewal. (n.d.). Parrot Analytics. https://www.parrotanalytics.com/insights/whats-behind-a-show-renewal/





## Loading the data

We will load the needed data files from the internet. It is all information that is not to do with the people that work on the movies/series, but rather the characteristics of the movies/series themselves

```{r warning=FALSE, message=FALSE}

# Define required packages
required_packages <- c("glue", "readr", "dplyr", "ggplot2", "knitr")

# Install missing packages
new_packages <- required_packages[!(required_packages %in% installed.packages()[, "Package"])]
if (length(new_packages)) install.packages(new_packages, type = "binary")

# Suppress startup messages while loading packages
suppressPackageStartupMessages({
  library(glue)
  library(readr)
  library(dplyr)
  library(ggplot2)
  library(knitr)
})
```

# Load the small dataset from Emma
```{r}
TV_series_data_clean <- read_csv("TV_series_data_clean.csv", show_col_types = FALSE)
```


## A clear overview: 
Though the glimpse function is useful, lets create a custom overview. Here we will look at (1) percentage of NA's, (2) vector type. (3) for numeric variables ranges for different variables to see if anthing sticks out and (4) number of unique values for charachter types

```{r message=FALSE}
library(knitr)
## find all the columns we  have in the first place
columns = colnames(TV_series_data_clean)




## create 3 empty dataframes. the first one stores whether a vector is a character or numeric. then based on this 
data_types_summary = data.frame(variable = character(), type = character(), percentage_na = character(), stringsAsFactors = FALSE)
data_types_numeric = data.frame(variable = character(), minimum = numeric(), maximum = numeric(), average_mean = numeric(), average_median = numeric(), average_mode = numeric(), binary = numeric(), stringsAsFactors = FALSE)
data_types_char = data.frame(variable = character(), unique_values = character(), stringsAsFactors = FALSE)

## We could not find a mode average function in r so we got this one from online 
## https://www.tutorialspoint.com/r/r_mean_median_mode.htm 

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

## Create a function whether a variable is binary 

binary_check = function(v) {
  if (all(v %in% c(0, 1))) {
  return(1)
  } else { 
  return(0)
    }
  
}




for (col in columns) {
  
  column_type = class(TV_series_data_clean[[col]])
  amount_na = (mean(is.na(TV_series_data_clean[[col]]))) * 100
  
  ## df1: The type of data from our main dataframe
  data_types_summary <- rbind(data_types_summary, data.frame(variable = col, type = column_type, percentage_na = amount_na, stringsAsFactors = FALSE))
  
  if (column_type == "numeric") {
    
    ## DF2: if a value is numeric the min and max value will be collected for this variable 
    min_value = min(TV_series_data_clean[[col]], na.rm = T)
    max_value = max(TV_series_data_clean[[col]], na.rm = T)
    mean_value =  mean(TV_series_data_clean[[col]], na.rm = T)
    median_value = median(TV_series_data_clean[[col]], na.rm = T)
    mode_value = getmode(TV_series_data_clean[[col]])
    binary_value = binary_check(TV_series_data_clean[[col]])

    
    data_types_numeric <- rbind(data_types_numeric, data.frame(variable = col, minumum = min_value, maximum = max_value, average_mean = mean_value, average_median = median_value, average_mode = mode_value, binary = binary_value, stringsAsFactors = FALSE))
    
  } else {
    
    ## DF3: if a value is not numeric it has to be character so the number of NAs are collected 
    number_unique_var = length(unique(TV_series_data_clean[[col]]))

    data_types_char <- rbind(data_types_char, data.frame(variable = col, unique_values = number_unique_var, stringsAsFactors = FALSE))
    
  }
  
  
}


kable(data_types_summary)
kable(data_types_numeric)
kable(data_types_char)
```

## looking at the numeric variables: course corrections
okay so looking at the numeric variables we could consider filtering them a bit already since the start year for some of them is 2026, which means it has not aired yet. In an article from parrot analytics they used a range of 80 days after the show airs (https://www.parrotanalytics.com/insights/whats-behind-a-show-renewal/). since this data has been updated as of match 2024, iyd more fair to only include data up to 2023 (to avoid recency bias)

Notwithstanding the NA's, the data seems to be in regular ranges, The variable types are also correct

```{r}

TV_series_data_clean = TV_series_data_clean %>%
  filter(startYear < 2024)

```



Okay so as mentioned earlier there are some NA's in the Dataset, for ones which the amount of na's is 100 percent will naturally have to be removed (as this means there is no data on them). as for the variables that do have an NAs it could be interesting to explore whether the NA data has different properties than the data which does not have NAs (for example if a lot of NA data on number of votes also has no renewals, this could influence how we interpret our final results)

First let show a bar plot of all the percentage of missing values 
```{r}
library(ggplot2)


ggplot(data_types_summary, aes(x = reorder(variable, -percentage_na), y = percentage_na)) +
  geom_bar(stat = "identity") + 
  labs(title = "NA vs Non-NA Values for All Columns",
       x = "Type variable",
       y = "Percentage of na values") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 

```


So in the plot we can already observe a lot of values for which all the information is missing. As aforementioned these need to be removed. the is Original title which only has the variable 1 can also be removed since this (according to the data) is always 1 anyways so we cannot really perform any analysis with this. We can also remove other variables like season number and episode number since they were more relevant to checking renewal status 

```{r}
library(glue)
library(dplyr)

## collecting variables for which there is no data (100 percent NA)
all_missing_data <- data_types_summary$variable[which(data_types_summary$percentage_na == 100)]

# Print the result
glue("missing all the data for: {all_missing_data}")

## Remove variables that dont say much (for example all values are 1 or 1 and NA)
useless_columns = c("isOriginalTitle", "ordering", "types")

useless_columns <- unique(c(all_missing_data, useless_columns))


TV_series_data_clean <- TV_series_data_clean %>%
  select(-all_of(useless_columns))

```
## Looking at our NA distribution before removing it

Though we can manually code each plot specifically, for simplicity sake, lets code make it smoother.   we can make the code even smoother by having it loop through all the variables that have more than one percent NA's. 

What is noticiable when looking at the plots is that the endyear data is missing for a lot of shows which are not renewed, this makes sense as shows that have no end year might still be currently airing. the same is true forruntime naturally. 

What we also found is that the NAs are more common in non-renewed shows for which the average data rating and non-voting data is missing. Though we cannot do much about this we can consider this relevant when filtering our data. We could consider doing a t test of some kind to determine whether these figures are significant.


```{r}
library(ggplot2)
library(dplyr)

### values which in the summary had more than one percent NA's
target_columns = data_types_summary$variable[which(data_types_summary$percentage_na > 1)]

## TAKE out already removed columns

columns = colnames(TV_series_data_clean)

target_columns <- target_columns[target_columns %in% columns]

irrelevant_for_eda = c("title", "Genre1_encoded", "Genre2_encoded", "Genre3_encoded")

target_columns <- target_columns[!target_columns %in% irrelevant_for_eda]


for (col in target_columns) {
  print(
    ggplot(TV_series_data_clean, aes(x = as.factor(Renewed), fill = as.factor(is.na(TV_series_data_clean[[col]])))) +
      geom_bar(position = "dodge") +  
      labs(title = paste("Comparison of NA vs. Non-NA in", col, "and TV Show Renewal"),
           x = "Renewal Status",
           y = "Count",
           fill = "Category") +
      scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "blue"), 
                        labels = c(paste(col, "Data Available"), paste(col, "Data Missing"))) +
      theme_minimal()
  )
}


```



```{r}

library(dplyr)
library(knitr)


na_summary_df <- data.frame(
  Variable = character(),
  Na_total = numeric(),
  na_total_renewed = numeric(),
  na_total_not_renewed = numeric(),
  na_percentage_total = numeric(),
  na_percentage_renewed = numeric(),
  na_percentage_not_renewed = numeric(),
  stringsAsFactors = FALSE
)

for (col in target_columns) {
  
  Na_count <- sum(is.na(TV_series_data_clean[[col]]))
  na_count_renewed <- sum(is.na(TV_series_data_clean[[col]]) & TV_series_data_clean$Renewed == 1)
  na_count_not_renewed <- sum(is.na(TV_series_data_clean[[col]]) & TV_series_data_clean$Renewed == 0)
  
  Na_percentage <- (Na_count / nrow(TV_series_data_clean)) * 100
  Na_percentage_renew <- (na_count_renewed / sum(TV_series_data_clean$Renewed == 1)) * 100
  Na_percentage_not_renew <- (na_count_not_renewed / sum(TV_series_data_clean$Renewed == 0)) * 100
  
  na_summary_df <- rbind(na_summary_df, data.frame(
    Variable = col,
    Na_total = Na_count,
    na_total_renewed = na_count_renewed,
    na_total_not_renewed = na_count_not_renewed,
    na_percentage_total = Na_percentage,
    na_percentage_renewed = Na_percentage_renew,
    na_percentage_not_renewed = Na_percentage_not_renew
  ))
}

# Print final dataframe
kable(na_summary_df)


```



## Removing the NA 
as our research is primarily concerned with renewals,average rating, popularity (lanauge is no longer in the dataset so that cant be studied), lets remove the data for which we have NA's for average rating and popularity (num votes)
```{r}
library(dplyr)

TV_series_data_clean = TV_series_data_clean %>%
  filter(!is.na(averageRating) & !is.na(numVotes)) 
```




## Looking at all the plots again
lets look at all the columns we have again with the variables we have
```{r}
remaining_columns = colnames(TV_series_data_clean)


columns_not_for_data_analysis = c("tconst", "parentTconst", "primaryTitle", "originalTitle", "title", "types")
          
remaining_columns <- setdiff(remaining_columns, columns_not_for_data_analysis)

print("We are going to look at the following variables in our EDA")
print(remaining_columns)
```


Here are the distributions of all numeric vectors, without genre, it is coded so that for binary factors it generates a barchart, and a boxplot for numeric factors
```{r}

remaining_columns_sans_genre = c("isAdult", "startYear", "endYear", "averageRating", "numVotes", "Renewed")

for (col in remaining_columns_sans_genre) {
  ## IF the factor was previously identified as numeric
  
  data_type = data_types_summary[which(data_types_summary$variable == col),"type"]

  
  if (data_type == "numeric") {
    
    binary = data_types_numeric[which(data_types_numeric$variable == col),"binary"]
    
    if (binary == 0) {
      
      boxplot(TV_series_data_clean[[col]], main = paste("Boxplot of", col), ylab = col)
      
      
      
      
      
    } else {
      
      
      barplot(table(TV_series_data_clean[[col]]), main = paste("Barplot of", col), xlab = col, ylab = "Count")
      
    }
      
      
    
    
    
  }
    

}



```

## GENRE encoding 
now lets look at genre. Since there are many genres and a given TV series can have a number of genres we can tally all the occurances of a genres.
```{r}
library(dplyr)
library(tidyr)
library(knitr)



genre_counts <- TV_series_data_clean %>%
  select(Genre1, Genre2, Genre3) %>%  
  pivot_longer(cols = everything(), names_to = "Genre_Type", values_to = "Genre") %>%  
  drop_na() %>% 
  count(Genre, sort = TRUE)  

# Display the result

genre_counts = genre_counts %>%
  mutate(percentage = (n/sum(n)*100))

kable(genre_counts)
```


as is evident from the table and the graph below, the most common genre is comedy, and drama, whereas western, war and musical are less popular
```{r}

ggplot(genre_counts, aes(x = reorder(Genre, -n), y = n, fill = Genre)) +
  geom_bar(stat = "identity") +
  labs(title = "TV Genre Distribution", x = "Genres", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill = "none") 

```

```{r}
ggplot(genre_counts, aes(x = reorder(Genre, -n), y = n, fill = Genre)) +
  geom_bar(stat = "identity") +
  labs(title = "TV Genre Distribution", x = "Genres", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill = "none") 
```